<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guppy Lab v2.9 - ÏûêÎèô Î≤àÏãù</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .aquarium {
            background: linear-gradient(to bottom, #0a2a43 0%, #0c4a6e 100%);
            border: 4px solid rgba(0, 229, 255, 0.3);
            border-radius: 1.5rem;
            box-shadow: 0 0 25px rgba(0, 229, 255, 0.3), inset 0 0 15px rgba(0,0,0,0.5);
            overflow: hidden; position: relative; width: 100%; aspect-ratio: 16 / 9;
        }
        .aquarium-nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background-color: rgba(15, 23, 42, 0.5);
            color: #67e8f9;
            border: 1px solid #334155;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            z-index: 30;
            transition: all 0.2s ease;
        }
        .aquarium-nav-arrow:hover {
            background-color: rgba(15, 23, 42, 0.8);
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
        }
        #prev-aquarium { left: -50px; }
        #next-aquarium { right: -50px; }

        .guppy {
            position: absolute; border-radius: 50%; 
            transition: transform 0.3s ease, width 0.5s ease, height 0.5s ease;
            cursor: pointer; transform-origin: center center; z-index: 5;
            filter: saturate(1.2);
        }
        .guppy.fry { width: 30px; height: 15px; }
        .guppy.adult { width: 50px; height: 25px; }
        .pattern-overlay { position: absolute; width: 100%; height: 100%; border-radius: 50%; }
        .guppy-tail {
            position: absolute; left: 0px; top: 50%; transform: translateY(-50%);
            width: 0; height: 0; border-top: 12px solid transparent; border-bottom: 12px solid transparent;
            border-left: 22px solid; transition: border-width 0.5s ease;
        }
        .guppy.fry .guppy-tail { border-top-width: 7px; border-bottom-width: 7px; border-left-width: 13px; }
        .guppy.selected {
            box-shadow: 0 0 15px 3px yellow;
            outline: none;
            z-index: 10;
        }
        
        .nibbling { animation: nibble 0.5s infinite alternate; }
        @keyframes nibble {
            0% { transform-origin: center; transform: rotate(-5deg) scaleX(1); }
            100% { transform-origin: center; transform: rotate(5deg) scaleX(1); }
        }
        .nibbling.flipped { animation-name: nibble-flipped; }
        @keyframes nibble-flipped {
            0% { transform-origin: center; transform: rotate(-5deg) scaleX(-1); }
            100% { transform-origin: center; transform: rotate(5deg) scaleX(-1); }
        }

        .bubble {
            position: absolute; bottom: -30px; width: 20px; height: 20px;
            background-color: rgba(0, 229, 255, 0.15);
            border: 1px solid rgba(0, 229, 255, 0.3);
            border-radius: 50%;
            animation: bubble-rise 5s infinite ease-in; z-index: 1;
        }
        @keyframes bubble-rise {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100vh); opacity: 0; }
        }
        .food-pellet {
            position: absolute; width: 6px; height: 6px;
            background-color: #c2783e;
            border-radius: 50%; z-index: 20;
            box-shadow: 0 0 5px #c2783e;
        }
        .progress-bar-bg { background-color: rgba(0,0,0,0.3); border-radius: 0.5rem; overflow: hidden; }
        .progress-bar { height: 100%; border-radius: 0.5rem; transition: width 0.3s ease-in-out; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(10, 20, 30, 0.8);
            backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }
        .modal-content {
            background: rgba(15, 23, 42, 0.9); border: 1px solid #1e293b;
            padding: 2rem; border-radius: 1rem;
            width: 90%; max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative;
        }
        .static-guppy-container {
            position: relative; width: 50px; height: 25px; flex-shrink: 0;
        }
        .static-guppy {
            position: absolute; border-radius: 50%; width: 50px; height: 25px;
        }
        .static-guppy-tail {
            position: absolute; left: 0px; top: 50%; transform: translateY(-50%);
            width: 0; height: 0; border-top: 12px solid transparent; border-bottom: 12px solid transparent;
            border-left: 22px solid;
        }
        #guppy-info-panel { z-index: 110; }
        .decoration {
            position: absolute;
            bottom: 0;
            transform: translateX(-50%);
            z-index: 2;
            filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.5));
        }
        .panel {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(8px);
            border: 1px solid #334155;
        }
        .btn {
            border: 1px solid #22d3ee;
            background: rgba(6, 182, 212, 0.1);
            color: #67e8f9;
            transition: all 0.2s ease;
        }
        .btn:hover {
            background: rgba(6, 182, 212, 0.2);
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
        }
        .btn-primary {
            background: #0891b2;
            border-color: #06b6d4;
            color: white;
        }
        .btn-primary:hover {
            background: #06b6d4;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.7);
        }
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(15, 23, 42, 0.9);
            color: #67e8f9;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 200;
            border: 1px solid #334155;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200">
    <!-- START: Intro Screen Wrapper -->
    <div id="intro-wrapper" class="relative flex flex-col justify-center items-center h-screen text-center p-4 w-full">
        <!-- Main intro content -->
        <div id="intro-screen">
            <h1 class="text-6xl font-bold text-cyan-300 mb-4" style="text-shadow: 0 0 15px rgba(6, 182, 212, 0.8);">Guppy Lab üê†</h1>
            <p class="text-xl text-slate-300 mb-8">ÎÇòÎßåÏùò ÌäπÎ≥ÑÌïú Íµ¨ÌîºÎ•º ÎßåÎì§Ïñ¥Î≥¥ÏÑ∏Ïöî!</p>
            <button id="start-button" class="bg-cyan-500 hover:bg-cyan-400 text-white font-bold py-4 px-10 rounded-full text-2xl shadow-lg shadow-cyan-500/50 transform hover:scale-105 transition-transform duration-300">
                Í≤åÏûÑ ÏãúÏûë
            </button>
        </div>
        <!-- Studio info footer -->
        <div class="absolute bottom-8 w-full">
            <img src="images/emblem.png" alt="Ìè¨ÎèÑ Ïä§ÌäúÎîîÏò§ Ïó†Î∏îÎüº" class="w-20 h-20 mx-auto mb-2">
            <p class="text-sm text-gray-400 font-jua">
                ÏÑ∏ÏÉÅÏóêÏÑú Í∞ÄÏû• Îã¨ÏΩ§Ìïú Í≤åÏûÑ
            </p>
            <a href="https://podo-studio.github.io/home/" target="_blank" class="text-sm text-blue-400 hover:text-blue-300 underline font-jua mt-1 inline-block">
                ÌôàÌéòÏù¥ÏßÄ Î∞îÎ°úÍ∞ÄÍ∏∞
            </a>
            <p class="text-xs text-gray-500 mt-2 font-jua">
                ¬© 2025 Podo Studio. All Rights Reserved.
            </p>
        </div>	
    </div>
    <!-- END: Intro Screen Wrapper -->

    <div id="main-app-screen" class="hidden flex-col items-center justify-center min-h-screen p-4">
        <div class="w-full max-w-4xl mx-auto">
            <header class="text-center mb-4 relative flex justify-center items-center">
                <h1 class="text-4xl font-bold text-cyan-300 mx-auto" style="text-shadow: 0 0 10px rgba(6, 182, 212, 0.7);">Guppy Lab üê†</h1>
                <div class="absolute top-0 right-0 flex space-x-2">
                    <button id="shop-button" class="btn w-10 h-10 rounded-full text-2xl">üõçÔ∏è</button>
                    <button id="collection-button" class="btn w-10 h-10 rounded-full text-2xl">üìñ</button>
                    <button id="guppy-list-button" class="btn w-10 h-10 rounded-full text-2xl">üêü</button>
                    <button id="manual-button" class="btn w-10 h-10 rounded-full text-2xl">?</button>
                </div>
            </header>

            <div class="panel p-3 rounded-xl mb-2 grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                <div>
                    <span class="font-bold text-lg text-cyan-400">üí∞ ÏΩîÏù∏</span>
                    <p id="coins-display" class="text-slate-200 text-xl">0</p>
                </div>
                <div>
                    <span class="font-bold text-lg text-cyan-400">üíß ÏàòÏßà</span>
                    <div class="progress-bar-bg h-4 mt-1"><div id="water-quality-bar" class="progress-bar bg-cyan-500" style="width: 100%;"></div></div>
                </div>
                <div class="col-span-2 grid grid-cols-2 gap-2">
                     <button id="feed-button" class="btn h-full rounded-lg">Î®πÏù¥Ï£ºÍ∏∞ (10üí∞)</button>
                     <button id="clean-button" class="btn h-full rounded-lg">Ï≤≠ÏÜåÌïòÍ∏∞</button>
                </div>
            </div>

            <div id="aquarium-title" class="text-center font-bold text-cyan-300 mb-2 text-lg"></div>
            <div id="aquarium-container" class="relative">
                <div id="prev-aquarium" class="aquarium-nav-arrow hidden">&lt;</div>
                <div id="aquarium" class="aquarium"></div>
                <div id="next-aquarium" class="aquarium-nav-arrow hidden">&gt;</div>
            </div>

            <div class="panel p-4 rounded-xl shadow-lg mt-4 text-center">
                 <button id="breed-button" class="btn btn-primary w-1/2 font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    ÍµêÎ∞∞ ÏãúÏûëÌïòÍ∏∞
                </button>
            </div>
            <div id="guppy-info-panel" class="panel fixed bottom-4 right-4 p-4 rounded-lg shadow-xl w-64 hidden">
                <h3 class="font-bold text-lg mb-2 text-cyan-400">Íµ¨Ìîº Ï†ïÎ≥¥</h3>
                <p id="info-id"></p>
                <div id="info-pattern-details"></div>
                <p id="info-age"></p>
                <p id="info-stage"></p>
                <p id="info-hunger"></p>
                <div class="mt-4 grid grid-cols-2 gap-2">
                    <button id="info-breed-button" class="btn text-sm">ÍµêÎ∞∞</button>
                    <button id="info-move-button" class="btn text-sm">ÏàòÏ°∞ Ïù¥Îèô</button>
                </div>
                 <button id="info-rehome-button" class="mt-2 w-full bg-red-500 hover:bg-red-600 text-white text-sm font-bold py-2 px-3 rounded">Î∂ÑÏñë</button>
                <button id="close-info-panel" class="absolute top-2 right-2 text-slate-400 hover:text-white">X</button>
            </div>
        </div>
    </div>

    <!-- Î™®Îã¨Îì§ -->
    <div id="modal-container"></div>


    <script>
        // --- DOM ÏöîÏÜå ---
        const introWrapper = document.getElementById('intro-wrapper');
        const mainAppScreen = document.getElementById('main-app-screen');
        const startButton = document.getElementById('start-button');
        const aquarium = document.getElementById('aquarium');
        const coinsDisplay = document.getElementById('coins-display');
        const waterQualityBar = document.getElementById('water-quality-bar');
        const feedButton = document.getElementById('feed-button');
        const cleanButton = document.getElementById('clean-button');
        const breedButton = document.getElementById('breed-button');
        const guppyInfoPanel = document.getElementById('guppy-info-panel');
        const closeInfoPanelButton = document.getElementById('close-info-panel');
        const infoBreedButton = document.getElementById('info-breed-button');
        const infoRehomeButton = document.getElementById('info-rehome-button');
        const infoMoveButton = document.getElementById('info-move-button');
        const manualButton = document.getElementById('manual-button');
        const guppyListButton = document.getElementById('guppy-list-button');
        const shopButton = document.getElementById('shop-button');
        const collectionButton = document.getElementById('collection-button');
        const modalContainer = document.getElementById('modal-container');
        const prevAquariumButton = document.getElementById('prev-aquarium');
        const nextAquariumButton = document.getElementById('next-aquarium');
        const aquariumTitle = document.getElementById('aquarium-title');

        // --- Í≤åÏûÑ ÏÑ§Ï†ï Î∞è Îç∞Ïù¥ÌÑ∞ ---
        const ADULT_AGE = 20;
        const MAX_HUNGER = 100;
        const HUNGRY_THRESHOLD = 70;
        const FEED_COST = 10;
        const BREED_COOLDOWN = 20000; // 20 seconds
        const PATTERN_TYPES = ['spots', 'stripes', 'h_stripes', 'v_stripes', 'freckles', 'half', 'rings', 'checker', 'gradient'];
        const SHOP_ITEMS = [
            { id: 'plant1', type: 'decoration', name: 'ÎÑ§Ïò® ÏàòÏ¥à', price: 50, effect: { waterQuality: 0.02 }, svg: `<svg width="50" height="100" viewBox="0 0 50 100"><path d="M25 100 C 10 80, 40 60, 25 40 S 10 20, 25 0" stroke="cyan" stroke-width="4" fill="none" /></svg>` },
            { id: 'guppy_red', type: 'guppy', name: 'Îπ®Í∞ï Ï†êÎ∞ïÏù¥ Íµ¨Ìîº', price: 100, pattern: { type: 'spots', colors: [{ r: 255, g: 20, b: 20 }, { r: 255, g: 20, b: 20 }] } },
            { id: 'guppy_blue', type: 'guppy', name: 'ÌååÎûë Ï§ÑÎ¨¥Îä¨ Íµ¨Ìîº', price: 120, pattern: { type: 'stripes', colors: [{ r: 20, g: 20, b: 255 }, { r: 20, g: 20, b: 255 }] } },
            { id: 'aquarium_new', type: 'aquarium', name: 'ÏÉàÎ°úÏö¥ ÏàòÏ°∞', price: 500 },
        ];

        let gameState = {
            aquariums: [{ guppies: [], decorations: [], waterQuality: 100, food: [] }],
            currentAquariumIndex: 0,
            nextGuppyId: 0, 
            coins: 100, 
            discoveredPatterns: new Set(),
            isBreedingMode: false, 
            breedingParents: [], 
            currentInfoGuppyId: null,
            isPaused: false,
        };
        let gameInitialized = false;

        const toRgbString = (color) => `rgb(${color.r}, ${color.g}, ${color.b})`;
        const roundToFive = (v) => Math.round(v / 5) * 5;

        class Food {
            constructor(x, y) { this.x = x; this.y = y; this.element = this.createElement(); }
            createElement() {
                const el = document.createElement('div');
                el.className = 'food-pellet';
                el.style.left = `${this.x}px`; el.style.top = `${this.y}px`;
                aquarium.appendChild(el); return el;
            }
            sink() { this.y += 0.5; this.element.style.top = `${this.y}px`; }
            destroy() { this.element.remove(); }
        }

        class Guppy {
            constructor(id, pattern, age = 0, parents = null, hunger = 0, lastBredTime = 0) {
                this.id = id; this.pattern = pattern; this.age = age; this.parents = parents; this.hunger = hunger;
                this.lastBredTime = lastBredTime;
                this.stage = this.age >= ADULT_AGE ? 'adult' : 'fry';
                this.x = Math.random() * (aquarium.clientWidth - 50);
                this.y = Math.random() * (aquarium.clientHeight - 25);
                this.target = null; this.speed = 1 + Math.random() * 1.5; this.isFlipped = false;
                this.nibbleTargetX = null;
                this.element = null; // Element is created when rendered in an aquarium
            }
            createElement() {
                const guppyEl = document.createElement('div');
                guppyEl.className = 'guppy'; guppyEl.dataset.id = this.id;
                guppyEl.style.left = `${this.x}px`; guppyEl.style.top = `${this.y}px`;
                const patternOverlay = document.createElement('div');
                patternOverlay.className = 'pattern-overlay'; guppyEl.appendChild(patternOverlay);
                const tail = document.createElement('div');
                tail.className = 'guppy-tail'; guppyEl.appendChild(tail);
                guppyEl.addEventListener('click', (e) => { 
                    e.stopPropagation();
                    if (gameState.isBreedingMode) {
                        selectBreedingGuppy(this);
                    } else {
                        showGuppyInfo(this);
                    }
                });
                aquarium.appendChild(guppyEl); 
                this.element = guppyEl;
                this.updateAppearance();
            }
            updateAppearance() {
                if (!this.element) return;
                this.element.classList.toggle('fry', this.stage === 'fry');
                this.element.classList.toggle('adult', this.stage === 'adult');
                const baseColor = toRgbString(this.pattern.colors[0]);
                this.element.style.backgroundColor = baseColor;
                const patternOverlay = this.element.querySelector('.pattern-overlay');
                patternOverlay.style.cssText = getPatternStyle(this.pattern);
                
                const tail = this.element.querySelector('.guppy-tail');
                const tailColor = toRgbString({ r: Math.max(0, this.pattern.colors[0].r - 30), g: Math.max(0, this.pattern.colors[0].g - 30), b: Math.max(0, this.pattern.colors[0].b - 30) });
                tail.style.borderLeftColor = tailColor;
            }
            grow() {
                this.age++; this.hunger = Math.min(MAX_HUNGER, this.hunger + 1);
                if (this.stage === 'fry' && this.age >= ADULT_AGE) { this.stage = 'adult'; this.updateAppearance(); }
            }
            decideBehavior(aquariumState) {
                if (aquariumState.food.length > 0) {
                    this.nibbleTargetX = null;
                    let closestFood = null; let minDistance = Infinity;
                    for (const food of aquariumState.food) {
                        const distance = Math.hypot(this.x - food.x, this.y - food.y);
                        if (distance < minDistance) { minDistance = distance; closestFood = food; }
                    }
                    this.target = closestFood; return;
                }
                if (this.hunger > HUNGRY_THRESHOLD) {
                    if (this.nibbleTargetX === null || Math.abs(this.x - this.nibbleTargetX) < 10) {
                        const guppyWidth = this.stage === 'adult' ? 50 : 30;
                        this.nibbleTargetX = Math.random() * (aquarium.clientWidth - guppyWidth);
                    }
                    this.target = { x: this.nibbleTargetX, y: 10 }; return;
                }
                
                this.nibbleTargetX = null;
                if (!this.target || (this.target && !aquariumState.food.includes(this.target))) {
                    this.target = { x: Math.random() * (aquarium.clientWidth - 50), y: Math.random() * (aquarium.clientHeight - 25) };
                }
            }
            updatePosition(aquariumState) {
                if (!this.target || !this.element) return;
                const dx = this.target.x - this.x; const dy = this.target.y - this.y;
                const distance = Math.hypot(dx, dy);

                if (this.hunger > HUNGRY_THRESHOLD && aquariumState.food.length === 0 && this.y < 30) {
                    this.element.classList.add('nibbling');
                    this.element.classList.toggle('flipped', this.isFlipped);
                } else {
                    this.element.classList.remove('nibbling', 'flipped');
                }

                if (distance < this.speed) {
                    if (this.target.constructor.name === 'Food') {
                        this.hunger = Math.max(0, this.hunger - 50); this.target.destroy();
                        aquariumState.food = aquariumState.food.filter(f => f !== this.target);
                    }
                    this.target = null; return;
                }
                const oldX = this.x;
                this.x += (dx / distance) * this.speed; this.y += (dy / distance) * this.speed;
                if (this.x !== oldX) {
                    this.isFlipped = this.x < oldX;
                    this.element.style.transform = this.isFlipped ? 'scaleX(-1)' : 'scaleX(1)';
                }
                this.element.style.left = `${this.x}px`; this.element.style.top = `${this.y}px`;
            }
            destroy() { if (this.element) this.element.remove(); this.element = null; }
        }
        
        class Decoration {
            constructor(item, x) {
                this.item = item;
                this.x = x;
                this.element = null;
            }
            createElement() {
                const el = document.createElement('div');
                el.className = 'decoration';
                el.innerHTML = this.item.svg;
                el.style.left = `${this.x}%`;
                aquarium.appendChild(el);
                this.element = el;
            }
            destroy() { if (this.element) this.element.remove(); this.element = null; }
        }
        
        function getPatternKey(pattern) {
            const roundValue = (v) => Math.min(255, Math.round(v / 20) * 20);
            return `${pattern.type}-${pattern.colors.map(c => `${roundValue(c.r)},${roundValue(c.g)},${roundValue(c.b)}`).join('-')}`;
        }

        function breedGuppies(parent1, parent2) {
            const inheritance = {};
            
            inheritance.pattern = Math.random() < 0.5 ? 1 : 2;
            const newPatternType = inheritance.pattern === 1 ? parent1.pattern.type : parent2.pattern.type;

            const newColors = [];
            inheritance.colors = [];
            
            const colorSlots = 2;
            
            for (let i = 0; i < colorSlots; i++) {
                const p1Color = parent1.pattern.colors[i] || parent1.pattern.colors[0];
                const p2Color = parent2.pattern.colors[i] || parent2.pattern.colors[0];
                
                const inheritFromParent1 = Math.random() < 0.5;
                const inheritedColor = inheritFromParent1 ? p1Color : p2Color;
                
                inheritance.colors.push({ from: inheritFromParent1 ? 1 : 2 });

                const newR = roundToFive(Math.max(0, Math.min(255, inheritedColor.r + Math.floor((Math.random() - 0.5) * 20))));
                const newG = roundToFive(Math.max(0, Math.min(255, inheritedColor.g + Math.floor((Math.random() - 0.5) * 20))));
                const newB = roundToFive(Math.max(0, Math.min(255, inheritedColor.b + Math.floor((Math.random() - 0.5) * 20))));
                
                newColors.push({ r: newR, g: newG, b: newB });
            }

            const newPattern = { type: newPatternType, colors: newColors };
            const patternKey = getPatternKey(newPattern);
            if (!gameState.discoveredPatterns.has(patternKey)) {
                gameState.discoveredPatterns.add(patternKey);
                gameState.coins += 50;
                showToast('+50 ÏΩîÏù∏! (ÏÉàÎ°úÏö¥ Ï°∞Ìï©)');
            }
            const newId = gameState.nextGuppyId++;
            const newGuppy = new Guppy(newId, newPattern);
            
            // [MODIFIED] Set spawn position near parents
            newGuppy.x = (parent1.x + parent2.x) / 2;
            newGuppy.y = (parent1.y + parent2.y) / 2;

            gameState.aquariums[gameState.currentAquariumIndex].guppies.push(newGuppy);
            newGuppy.createElement(); // Create element in the current aquarium
            
            return { newGuppy, inheritance };
        }
        function calculateGuppyValue(guppy) {
            if (guppy.stage !== 'adult') return 0;
            let value = 10;
            const patternValues = { spots: 15, stripes: 20, h_stripes: 20, v_stripes: 20, freckles: 25, half: 30, rings: 35, checker: 40, gradient: 50 };
            value += patternValues[guppy.pattern.type] || 0;
            guppy.pattern.colors.forEach(c => {
                const avg = (c.r + c.g + c.b) / 3;
                const stdDev = Math.sqrt(((c.r - avg)**2 + (c.g - avg)**2 + (c.b - avg)**2) / 3);
                value += Math.floor(stdDev / 10);
            });
            if (guppy.pattern.colors.length > 1) {
                const c1 = guppy.pattern.colors[0];
                const c2 = guppy.pattern.colors[1];
                const colorDiff = Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
                value += Math.floor(colorDiff / 50);
            }
            return value;
        }
        function rehomeGuppy(guppyId) {
            const currentAq = gameState.aquariums[gameState.currentAquariumIndex];
            const guppyIndex = currentAq.guppies.findIndex(g => g.id === guppyId);
            if (guppyIndex === -1) return;
            const guppy = currentAq.guppies[guppyIndex];
            const value = calculateGuppyValue(guppy);
            if (value === 0) {
                showToast('ÏπòÏñ¥Îäî Î∂ÑÏñë Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.');
                return;
            }
            showConfirmation(`${value} ÏΩîÏù∏ÏùÑ Î∞õÍ≥† Ïù¥ Íµ¨ÌîºÎ•º Î∂ÑÏñë Î≥¥ÎÇ¥ÏãúÍ≤†ÏäµÎãàÍπå?`, () => {
                gameState.coins += value;
                guppy.destroy();
                currentAq.guppies.splice(guppyIndex, 1);
                gameState.breedingParents = gameState.breedingParents.filter(p => p.id !== guppyId);
                updateUI();
                const modal = document.getElementById('guppy-list-modal');
                if (modal) {
                    modal.remove();
                    openGuppyList(); // Refresh the list
                }
            });
        }
        function showConfirmation(message, onConfirm) {
            const confirmModal = document.createElement('div');
            confirmModal.id = 'confirm-modal';
            confirmModal.className = 'modal-overlay';
            confirmModal.innerHTML = `
                <div class="modal-content text-center">
                    <p id="confirm-message" class="text-lg mb-6">${message}</p>
                    <div class="flex justify-center space-x-4">
                        <button id="confirm-yes-button" class="btn btn-primary py-2 px-8 rounded-lg">Ïòà</button>
                        <button id="confirm-no-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-8 rounded-lg">ÏïÑÎãàÏò§</button>
                    </div>
                </div>`;
            modalContainer.appendChild(confirmModal);

            const yesHandler = () => {
                onConfirm();
                modalContainer.removeChild(confirmModal);
            };
            const noHandler = () => {
                modalContainer.removeChild(confirmModal);
            };

            confirmModal.querySelector('#confirm-yes-button').addEventListener('click', yesHandler);
            confirmModal.querySelector('#confirm-no-button').addEventListener('click', noHandler);
        }
        function updateUI() {
            const currentAq = gameState.aquariums[gameState.currentAquariumIndex];
            coinsDisplay.textContent = gameState.coins; 
            waterQualityBar.style.width = `${currentAq.waterQuality}%`; 
            aquariumTitle.textContent = `ÏàòÏ°∞ ${gameState.currentAquariumIndex + 1} / ${gameState.aquariums.length}`;
            updateAquariumNav();
        }
        function saveGame() {
            const plainState = JSON.parse(JSON.stringify(gameState));
            plainState.aquariums.forEach(aq => {
                aq.guppies.forEach(g => {
                    delete g.element; // Don't save DOM elements
                    delete g.target;
                });
                aq.decorations.forEach(d => delete d.element);
                aq.food = [];
            });
            plainState.discoveredPatterns = Array.from(plainState.discoveredPatterns);
            localStorage.setItem('guppyLabSave', JSON.stringify(plainState));
        }
        function loadGame() {
            const savedData = localStorage.getItem('guppyLabSave');
            if (savedData) {
                const loadedState = JSON.parse(savedData);
                gameState = { ...gameState, ...loadedState };
                gameState.discoveredPatterns = new Set(loadedState.discoveredPatterns);
                
                gameState.aquariums.forEach(aqData => {
                    const guppies = aqData.guppies.map(gData => new Guppy(gData.id, gData.pattern, gData.age, gData.parents, gData.hunger, gData.lastBredTime || 0));
                    const decorations = aqData.decorations.map(dData => {
                        const item = SHOP_ITEMS.find(i => i.id === dData.item.id);
                        return new Decoration(item, dData.x);
                    });
                    aqData.guppies = guppies;
                    aqData.decorations = decorations;
                    aqData.food = [];
                });
                return true;
            }
            return false;
        }
        function renderLoop() {
            if (!gameState.isPaused) {
                const currentAq = gameState.aquariums[gameState.currentAquariumIndex];
                currentAq.food.forEach((food, index) => {
                    food.sink();
                    if (food.y > aquarium.clientHeight) { food.destroy(); currentAq.food.splice(index, 1); }
                });
                currentAq.guppies.forEach(guppy => guppy.updatePosition(currentAq));
            }
            requestAnimationFrame(renderLoop);
        }
        function tickLoop() {
            if (!gameState.isPaused) {
                gameState.aquariums.forEach((aq, aqIndex) => {
                    // Grow and decide behavior for all guppies
                    aq.guppies.forEach(guppy => { 
                        guppy.grow(); 
                        guppy.decideBehavior(aq); 
                    });
                    
                    // Handle water degradation
                    let waterQualityModifier = 1;
                    aq.decorations.forEach(deco => {
                        if (deco.item.effect && deco.item.effect.waterQuality) {
                            waterQualityModifier -= deco.item.effect.waterQuality;
                        }
                    });
                    const degradation = aq.guppies.length * 0.1 * waterQualityModifier;
                    aq.waterQuality = Math.max(0, aq.waterQuality - degradation);

                    // Handle automatic breeding
                    const adults = aq.guppies.filter(g => g.stage === 'adult');
                    const now = Date.now();

                    for (let i = 0; i < adults.length; i++) {
                        const g1 = adults[i];

                        if (g1.hunger < 20 && (now - g1.lastBredTime > BREED_COOLDOWN)) {
                            for (let j = i + 1; j < adults.length; j++) {
                                const g2 = adults[j];

                                if (g2.hunger < 20 && (now - g2.lastBredTime > BREED_COOLDOWN)) {
                                    const distance = Math.hypot(g1.x - g2.x, g1.y - g2.y);
                                    const adultWidth = 50;

                                    if (distance < adultWidth) {
                                        breedGuppies(g1, g2);

                                        g1.lastBredTime = now;
                                        g2.lastBredTime = now;
                                        g1.hunger = 50;
                                        g2.hunger = 50;

                                        if (aqIndex === gameState.currentAquariumIndex) {
                                            showToast('ÏÉàÎ°úÏö¥ ÏπòÏñ¥Í∞Ä ÌÉúÏñ¥ÎÇ¨ÏäµÎãàÎã§!');
                                        }
                                        break; 
                                    }
                                }
                            }
                        }
                    }
                });
            }
            updateUI(); 
            saveGame();
        }

        function openGuppyList() {
            const currentAq = gameState.aquariums[gameState.currentAquariumIndex];
            const guppyListModal = document.createElement('div');
            guppyListModal.id = 'guppy-list-modal';
            guppyListModal.className = 'modal-overlay';
            let listContent = '';
            if (currentAq.guppies.length === 0) {
                listContent = '<p class="text-slate-400">Ïù¥ ÏàòÏ°∞ÏóêÎäî Íµ¨ÌîºÍ∞Ä ÏóÜÏäµÎãàÎã§.</p>';
            } else {
                 listContent = currentAq.guppies.map(guppy => {
                    const value = calculateGuppyValue(guppy);
                    const colorsHTML = guppy.pattern.colors.map(c => `
                        <div class="flex items-center space-x-1 text-xs">
                            <div class="w-3 h-3 rounded-full border border-slate-600" style="background-color: ${toRgbString(c)}"></div>
                            <span class="text-slate-500">R:${c.r} G:${c.g} B:${c.b}</span>
                        </div>
                    `).join('');

                    return `
                    <div class="flex items-center p-2 rounded-lg hover:bg-slate-800">
                        <div class="flex-1 flex items-center cursor-pointer" onclick="showGuppyInfoById(${guppy.id})">
                            <div class="static-guppy-container mr-4">
                                <div class="static-guppy" style="background-color: ${toRgbString(guppy.pattern.colors[0])};">
                                    <div class="pattern-overlay" style="${getPatternStyle(guppy.pattern)}"></div>
                                    <div class="static-guppy-tail" style="border-left-color: ${toRgbString({r: Math.max(0, guppy.pattern.colors[0].r - 30), g: Math.max(0, guppy.pattern.colors[0].g - 30), b: Math.max(0, guppy.pattern.colors[0].b - 30)})};"></div>
                                </div>
                            </div>
                            <div>
                                <p class="font-bold">ID: ${guppy.id} (${guppy.stage === 'fry' ? 'ÏπòÏñ¥' : 'ÏÑ±Ïñ¥'})</p>
                                <p class="text-sm text-slate-400">Ìå®ÌÑ¥: ${guppy.pattern.type}</p>
                                <div class="mt-1 space-y-1">${colorsHTML}</div>
                            </div>
                        </div>
                        <button data-guppy-id="${guppy.id}" class="rehome-button ml-4 bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded text-sm ${guppy.stage === 'fry' ? 'opacity-50 cursor-not-allowed' : ''}" ${guppy.stage === 'fry' ? 'disabled' : ''}>
                            Î∂ÑÏñë (${value}üí∞)
                        </button>
                    </div>`;
                }).join('');
            }

            guppyListModal.innerHTML = `
                <div class="modal-content">
                    <button class="close-modal-button absolute top-4 right-4 text-2xl font-bold text-slate-400 hover:text-white">&times;</button>
                    <h2 class="text-3xl font-bold mb-4 text-cyan-300">ÎÇ¥ Íµ¨Ìîº Î™©Î°ù (ÏàòÏ°∞ ${gameState.currentAquariumIndex + 1})</h2>
                    <div class="space-y-3">${listContent}</div>
                </div>
            `;
            modalContainer.appendChild(guppyListModal);
        }
        
        function findGuppyById(guppyId) {
            for (const aq of gameState.aquariums) {
                const guppy = aq.guppies.find(g => g.id === guppyId);
                if (guppy) return guppy;
            }
            return null;
        }

        function showGuppyInfoById(guppyId) {
            const guppy = findGuppyById(guppyId);
            if (guppy) {
                showGuppyInfo(guppy);
                const modal = document.getElementById('guppy-list-modal');
                if(modal) modal.remove();
            }
        }
        function showGuppyInfo(guppy) {
            try {
                gameState.currentInfoGuppyId = guppy.id;
                const el = (id) => document.getElementById(id);
                el('info-id').textContent = `ID: ${guppy.id}`;
                const pd = el('info-pattern-details');
                const colorsHTML = guppy.pattern.colors.map(c => `
                    <div class="flex items-center space-x-2 text-sm">
                        <div class="w-3 h-3 rounded-full border border-slate-600" style="background-color: ${toRgbString(c)}"></div>
                        <span class="text-slate-400">R:${c.r} G:${c.g} B:${c.b}</span>
                    </div>
                `).join('');
                pd.innerHTML = `
                    <p>Ìå®ÌÑ¥: ${guppy.pattern.type}</p>
                    <div class="mt-1 space-y-1">${colorsHTML}</div>
                `;
                el('info-age').textContent = `ÎÇòÏù¥: ${guppy.age}Ï¥à`;
                el('info-stage').textContent = `Îã®Í≥Ñ: ${guppy.stage === 'fry' ? 'ÏπòÏñ¥' : 'ÏÑ±Ïñ¥'}`;
                el('info-hunger').textContent = `ÌóàÍ∏∞: ${guppy.hunger} / ${MAX_HUNGER}`;
                infoMoveButton.classList.toggle('hidden', gameState.aquariums.length <= 1);
                guppyInfoPanel.classList.remove('hidden');
            } catch (e) {
                console.error('showGuppyInfo Ïò§Î•ò:', e);
            }
        }
    

        function getPatternStyle(pattern) {
            if (pattern.colors.length > 1) {
                const c1 = toRgbString(pattern.colors[0]);
                const c2 = toRgbString(pattern.colors[1]);
                if (c1 === c2) return '';
                switch (pattern.type) {
                    case 'spots': return `background: radial-gradient(${c2} 20%, transparent 25%); background-size: 15px 15px;`;
                    case 'stripes': return `background: repeating-linear-gradient(45deg, ${c2}, ${c2} 5px, transparent 5px, transparent 10px);`;
                    case 'h_stripes': return `background: repeating-linear-gradient(to bottom, ${c2}, ${c2} 5px, transparent 5px, transparent 10px);`;
                    case 'v_stripes': return `background: repeating-linear-gradient(to right, ${c2}, ${c2} 5px, transparent 5px, transparent 10px);`;
                    case 'freckles': return `background: radial-gradient(${c2} 10%, transparent 15%); background-size: 10px 10px;`;
                    case 'half': return `background: linear-gradient(to right, ${c1} 50%, ${c2} 50%);`;
                    case 'rings': return `background: repeating-radial-gradient(circle, ${c2}, ${c2} 3px, transparent 3px, transparent 9px);`;
                    case 'checker': return `background-image: linear-gradient(45deg, ${c2} 25%, transparent 25%), linear-gradient(-45deg, ${c2} 25%, transparent 25%), linear-gradient(45deg, transparent 75%, ${c2} 75%), linear-gradient(-45deg, transparent 75%, ${c2} 75%); background-size: 10px 10px;`;
                    case 'gradient': return `background: radial-gradient(circle, ${c1}, ${c2});`;
                }
            }
            return '';
        }
        
        function openShop() {
            const shopModal = document.createElement('div');
            shopModal.id = 'shop-modal';
            shopModal.className = 'modal-overlay';
            const itemsHTML = SHOP_ITEMS.map(item => {
                let itemPreview = '';
                if (item.type === 'decoration') {
                    itemPreview = `<div class="flex justify-center items-center h-24">${item.svg}</div>
                        <div><p class="font-bold">${item.name}</p><p class="text-sm text-slate-400">Ìö®Í≥º: ÏàòÏßà Ï†ïÌôî</p></div>`;
                } else if (item.type === 'guppy') {
                    itemPreview = `<div class="flex justify-center items-center h-24">
                            <div class="static-guppy-container">
                                <div class="static-guppy" style="background-color: ${toRgbString(item.pattern.colors[0])};">
                                    <div class="pattern-overlay" style="${getPatternStyle(item.pattern)}"></div>
                                    <div class="static-guppy-tail" style="border-left-color: ${toRgbString({r: Math.max(0, item.pattern.colors[0].r - 30), g: Math.max(0, item.pattern.colors[0].g - 30), b: Math.max(0, item.pattern.colors[0].b - 30)})};"></div>
                                </div>
                            </div>
                        </div>
                        <div><p class="font-bold">${item.name}</p><p class="text-sm text-slate-400">Í∏∞Î≥∏ ÌòàÌÜµ</p></div>`;
                } else if (item.type === 'aquarium') {
                     itemPreview = `<div class="flex justify-center items-center h-24 text-6xl">üê†</div>
                        <div><p class="font-bold">${item.name}</p><p class="text-sm text-slate-400">Íµ¨ÌîºÎ•º Îçî ÌÇ§ÏõåÎ≥¥ÏÑ∏Ïöî</p></div>`;
                }
                return `<div class="border border-slate-700 rounded-lg p-2 text-center flex flex-col justify-between">
                    ${itemPreview}
                    <button data-item-id="${item.id}" class="buy-button mt-2 w-full btn">${item.price} üí∞</button>
                </div>`;
            }).join('');

            shopModal.innerHTML = `
                <div class="modal-content">
                    <button class="close-modal-button absolute top-4 right-4 text-2xl font-bold text-slate-400 hover:text-white">&times;</button>
                    <h2 class="text-3xl font-bold mb-4 text-cyan-300">ÏÉÅÏ†ê üõçÔ∏è</h2>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-4">${itemsHTML}</div>
                </div>`;
            modalContainer.appendChild(shopModal);
        }

        function buyItem(itemId) {
            const item = SHOP_ITEMS.find(i => i.id === itemId);
            if (gameState.coins >= item.price) {
                gameState.coins -= item.price;
                if (item.type === 'decoration') {
                    const xPos = 10 + Math.random() * 80;
                    const newDeco = new Decoration(item, xPos);
                    gameState.aquariums[gameState.currentAquariumIndex].decorations.push(newDeco);
                    newDeco.createElement();
                } else if (item.type === 'guppy') {
                    const newId = gameState.nextGuppyId++;
                    const newGuppy = new Guppy(newId, item.pattern);
                    gameState.aquariums[gameState.currentAquariumIndex].guppies.push(newGuppy);
                    newGuppy.createElement();
                    const patternKey = getPatternKey(item.pattern);
                    if (!gameState.discoveredPatterns.has(patternKey)) {
                        gameState.discoveredPatterns.add(patternKey);
                    }
                } else if (item.type === 'aquarium') {
                    gameState.aquariums.push({ guppies: [], decorations: [], waterQuality: 100, food: [] });
                    switchAquarium(gameState.aquariums.length - 1 - gameState.currentAquariumIndex);
                }
                const modal = document.getElementById('shop-modal');
                if(modal) modal.remove();
                updateUI();
            } else {
                showToast('ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!');
            }
        }

        function openCollection() {
             const collectionModal = document.createElement('div');
            collectionModal.id = 'collection-modal';
            collectionModal.className = 'modal-overlay';
            
            let collectionHTML = '';
            gameState.discoveredPatterns.forEach(patternKey => {
                const [type, ...colorsStr] = patternKey.split('-');
                const colors = colorsStr.map(cs => {
                    const [r,g,b] = cs.split(',');
                    return { r: parseInt(r), g: parseInt(g), b: parseInt(b) };
                });
                const pattern = { type, colors };
                const colorsHTML = pattern.colors.map(c => `
                    <div class="flex items-center space-x-2">
                        <div class="w-4 h-4 rounded-full border border-slate-600" style="background-color: ${toRgbString(c)}"></div>
                        <p class="text-xs text-slate-400">R:${c.r} G:${c.g} B:${c.b}</p>
                    </div>`).join('');

                collectionHTML += `
                    <div class="flex items-center p-2 rounded-lg border border-slate-700">
                        <div class="static-guppy-container mr-4">
                            <div class="static-guppy" style="background-color: ${toRgbString(pattern.colors[0])};">
                                <div class="pattern-overlay" style="${getPatternStyle(pattern)}"></div>
                                <div class="static-guppy-tail" style="border-left-color: ${toRgbString({r: Math.max(0, pattern.colors[0].r - 30), g: Math.max(0, pattern.colors[0].g - 30), b: Math.max(0, pattern.colors[0].b - 30)})};"></div>
                            </div>
                        </div>
                        <div>
                            <p class="font-bold capitalize">${pattern.type}</p>
                            <div class="flex flex-col space-y-1 mt-1">${colorsHTML}</div>
                        </div>
                    </div>`;
            });

            collectionModal.innerHTML = `
                <div class="modal-content">
                    <button class="close-modal-button absolute top-4 right-4 text-2xl font-bold text-slate-400 hover:text-white">&times;</button>
                    <h2 class="text-3xl font-bold mb-4 text-cyan-300">ÎèÑÍ∞ê üìñ</h2>
                    <p class="mb-4 text-slate-400">ÏßÄÍ∏àÍπåÏßÄ Î∞úÍ≤¨Ìïú Íµ¨ÌîºÎì§ÏûÖÎãàÎã§. ${gameState.discoveredPatterns.size} / ?</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">${collectionHTML}</div>
                </div>`;
            modalContainer.appendChild(collectionModal);
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.top = '30px';
            }, 10);
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.top = '20px';
                setTimeout(() => toast.remove(), 500);
            }, 2000);
        }

        function startBreeding(firstParent = null) {
            gameState.isPaused = true;
            gameState.isBreedingMode = true;
            gameState.breedingParents = firstParent ? [firstParent] : [];
            guppyInfoPanel.classList.add('hidden');
            updateAllGuppySelectionUI();
            if (firstParent) {
                showToast(`Î∂ÄÎ™® 1 ÏÑ†ÌÉù ÏôÑÎ£å! ÍµêÎ∞∞Ìï† Îã§Î•∏ Íµ¨ÌîºÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.`);
            } else {
                showToast('ÍµêÎ∞∞Ìï† Ï≤´ Î≤àÏß∏ Íµ¨ÌîºÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
            }
        }

        function selectBreedingGuppy(guppy) {
            if (guppy.stage !== 'adult') {
                showToast('ÏÑ±Ïñ¥Îßå ÍµêÎ∞∞Ìï† Ïàò ÏûàÏäµÎãàÎã§.');
                return;
            }
            if (gameState.breedingParents.length > 0 && gameState.breedingParents[0].id === guppy.id) return;

            gameState.breedingParents.push(guppy);
            updateAllGuppySelectionUI();

            if (gameState.breedingParents.length === 2) {
                openBreedModal();
                gameState.isBreedingMode = false;
            } else {
                showToast(`Î∂ÄÎ™® 1 ÏÑ†ÌÉù ÏôÑÎ£å! ÍµêÎ∞∞Ìï† Îã§Î•∏ Íµ¨ÌîºÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.`);
            }
        }
        
        function cancelBreeding() {
            gameState.isPaused = false;
            gameState.isBreedingMode = false;
            gameState.breedingParents = [];
            updateAllGuppySelectionUI();
        }

        function updateAllGuppySelectionUI() {
            gameState.aquariums[gameState.currentAquariumIndex].guppies.forEach(g => {
                if (g.element) {
                    const isSelected = gameState.breedingParents.some(p => p.id === g.id);
                    g.element.classList.toggle('selected', isSelected);
                }
            });
        }

        function openBreedModal() {
            const [p1, p2] = gameState.breedingParents;
            const breedModal = document.createElement('div');
            breedModal.id = 'breed-modal';
            breedModal.className = 'modal-overlay';
            breedModal.innerHTML = `
                <div class="modal-content">
                    <button class="close-modal-button absolute top-4 right-4 text-2xl font-bold text-slate-400 hover:text-white">&times;</button>
                    <h2 class="text-3xl font-bold mb-4 text-cyan-300">ÍµêÎ∞∞ Ïó∞Íµ¨ÏÜå</h2>
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="text-center p-2 border border-slate-700 rounded-lg">${getGuppyCardHTML(p1)}</div>
                        <div class="text-center p-2 border border-slate-700 rounded-lg">${getGuppyCardHTML(p2)}</div>
                    </div>
                    <div id="breed-action-container" class="text-center mb-4">
                        <button id="final-breed-button" class="btn btn-primary font-bold py-2 px-8 rounded-lg">ÍµêÎ∞∞ Ïã§Ìñâ</button>
                    </div>
                    <div id="breed-result-container" class="hidden">
                        <h3 class="text-xl font-semibold mt-6 mb-2 text-cyan-400">Í≤∞Í≥º</h3>
                        <div id="breed-result-guppy" class="flex justify-center items-center p-2 border border-slate-700 rounded-lg"></div>
                        <h4 class="text-lg font-semibold mt-4 mb-2 text-cyan-400">Ïú†Ï†Ñ Î≥¥Í≥†ÏÑú</h4>
                        <div id="breed-report" class="text-sm bg-slate-900/50 p-3 rounded-lg border border-slate-700 space-y-1"></div>
                        <div class="text-center mt-4">
                            <button id="breed-result-close-button" class="btn w-1/2">Îã´Í∏∞</button>
                        </div>
                    </div>
                </div>
            `;
            modalContainer.appendChild(breedModal);
            
            breedModal.querySelector('#final-breed-button').addEventListener('click', () => {
                const { newGuppy, inheritance } = breedGuppies(p1, p2);
                breedModal.querySelector('#breed-result-guppy').innerHTML = getGuppyCardHTML(newGuppy);
                
                let reportHTML = `<p>Ìå®ÌÑ¥: ${newGuppy.pattern.type} (Î∂ÄÎ™® ${inheritance.pattern}ÏóêÍ≤åÏÑú Ïú†Ï†Ñ)</p>`;
                newGuppy.pattern.colors.forEach((childColor, i) => {
                    const colorLabel = i === 0 ? 'Î™∏ÌÜµÏÉâ' : `Î¨¥Îä¨ÏÉâ${i}`;
                    const inheritanceInfo = inheritance.colors[i];
                    const parentNum = inheritanceInfo.from;
                    const parentColor = parentNum === 1 
                        ? (p1.pattern.colors[i] || p1.pattern.colors[0])
                        : (p2.pattern.colors[i] || p2.pattern.colors[0]);

                    reportHTML += `
                        <div class="p-2 my-1 bg-slate-800 rounded">
                            <p class="font-semibold">${colorLabel}: 
                                <span class="inline-flex items-center space-x-1">
                                    <span class="w-3 h-3 rounded-full border border-slate-600" style="background-color: ${toRgbString(childColor)}"></span>
                                    <span>R:${childColor.r} G:${childColor.g} B:${childColor.b}</span>
                                </span>
                            </p>
                            <p class="text-xs text-slate-400 pl-4">Î∂ÄÎ™® ${parentNum}Ïùò ÏÉâÏÉÅ(R:${parentColor.r} G:${parentColor.g} B:${parentColor.b})ÏóêÏÑú Î≥ÄÏù¥</p>
                        </div>
                    `;
                });
                breedModal.querySelector('#breed-report').innerHTML = reportHTML;

                breedModal.querySelector('#breed-action-container').classList.add('hidden');
                breedModal.querySelector('#breed-result-container').classList.remove('hidden');
                cancelBreeding();
            });
            breedModal.querySelector('#breed-result-close-button').addEventListener('click', () => {
                if(gameState.isPaused) cancelBreeding();
                breedModal.remove();
            });
        }
        
        function getGuppyCardHTML(guppy) {
            const colorsHTML = guppy.pattern.colors.map(c => `
                <div class="flex items-center space-x-1 text-xs">
                    <div class="w-3 h-3 rounded-full border border-slate-600" style="background-color: ${toRgbString(c)}"></div>
                    <span class="text-slate-500">R:${c.r} G:${c.g} B:${c.b}</span>
                </div>
            `).join('');

            let html = `
                <div class="flex justify-center mb-4">
                    <div class="static-guppy-container">
                        <div class="static-guppy" style="background-color: ${toRgbString(guppy.pattern.colors[0])};">
                            <div class="pattern-overlay" style="${getPatternStyle(guppy.pattern)}"></div>
                            <div class="static-guppy-tail" style="border-left-color: ${toRgbString({r: Math.max(0, guppy.pattern.colors[0].r - 30), g: Math.max(0, guppy.pattern.colors[0].g - 30), b: Math.max(0, guppy.pattern.colors[0].b - 30)})};"></div>
                        </div>
                    </div>
                </div>
                <p class="font-bold">ID: ${guppy.id || 'ÏÉàÎ°úÏö¥ Íµ¨Ìîº'}</p>
                <p class="text-sm">Ìå®ÌÑ¥: ${guppy.pattern.type}</p>
                <div class="mt-1 space-y-1 text-left inline-block">${colorsHTML}</div>
            `;
            return html;
        }

        function renderCurrentAquarium() {
            // Clear everything except bubbles
            const bubbles = aquarium.querySelectorAll('.bubble');
            aquarium.innerHTML = '';
            bubbles.forEach(b => aquarium.appendChild(b));

            const currentAq = gameState.aquariums[gameState.currentAquariumIndex];
            currentAq.guppies.forEach(g => g.createElement());
            currentAq.decorations.forEach(d => d.createElement());
            currentAq.food.forEach(f => f.createElement());
            updateUI();
        }

        function switchAquarium(direction) {
            const newIndex = gameState.currentAquariumIndex + direction;
            if (newIndex >= 0 && newIndex < gameState.aquariums.length) {
                gameState.currentAquariumIndex = newIndex;
                renderCurrentAquarium();
            }
        }

        function updateAquariumNav() {
            prevAquariumButton.classList.toggle('hidden', gameState.currentAquariumIndex === 0);
            nextAquariumButton.classList.toggle('hidden', gameState.currentAquariumIndex === gameState.aquariums.length - 1);
        }
        
        function openMoveGuppyModal() {
            const guppy = findGuppyById(gameState.currentInfoGuppyId);
            if (!guppy) return;

            const moveModal = document.createElement('div');
            moveModal.id = 'move-guppy-modal';
            moveModal.className = 'modal-overlay';

            let optionsHTML = '';
            gameState.aquariums.forEach((aq, index) => {
                if (index !== gameState.currentAquariumIndex) {
                    optionsHTML += `<button class="move-to-aq-button btn w-full" data-target-index="${index}">ÏàòÏ°∞ ${index + 1} (Ïúº)Î°ú Î≥¥ÎÇ¥Í∏∞</button>`;
                }
            });

            moveModal.innerHTML = `
                <div class="modal-content">
                    <button class="close-modal-button absolute top-4 right-4 text-2xl font-bold text-slate-400 hover:text-white">&times;</button>
                    <h2 class="text-2xl font-bold mb-4 text-cyan-300">Ïñ¥ÎîîÎ°ú ÏòÆÍ∏∏ÍπåÏöî?</h2>
                    <div class="space-y-2">${optionsHTML}</div>
                </div>
            `;
            modalContainer.appendChild(moveModal);
        }

        // --- Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ---
        startButton.addEventListener('click', () => {
            introWrapper.classList.add('hidden');
            mainAppScreen.classList.remove('hidden');
            mainAppScreen.classList.add('flex');
            if (!gameInitialized) {
                init();
                gameInitialized = true;
            }
        });

        feedButton.addEventListener('click', () => {
            if (gameState.coins >= FEED_COST) {
                gameState.coins -= FEED_COST;
                const currentAq = gameState.aquariums[gameState.currentAquariumIndex];
                for (let i = 0; i < 15; i++) {
                    const x = Math.random() * (aquarium.clientWidth - 10);
                    const y = Math.random() * 20;
                    currentAq.food.push(new Food(x, y));
                }
            } else { showToast('ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!'); }
        });
        cleanButton.addEventListener('click', () => { 
            gameState.aquariums[gameState.currentAquariumIndex].waterQuality = 100;
            updateUI();
        });
        breedButton.addEventListener('click', () => startBreeding());
        
        infoBreedButton.addEventListener('click', () => {
            const guppy = findGuppyById(gameState.currentInfoGuppyId);
            if (guppy) startBreeding(guppy);
        });
        
        infoRehomeButton.addEventListener('click', () => {
            rehomeGuppy(gameState.currentInfoGuppyId);
            guppyInfoPanel.classList.add('hidden');
        });
        
        infoMoveButton.addEventListener('click', openMoveGuppyModal);
        
        closeInfoPanelButton.addEventListener('click', () => guppyInfoPanel.classList.add('hidden'));

        prevAquariumButton.addEventListener('click', () => switchAquarium(-1));
        nextAquariumButton.addEventListener('click', () => switchAquarium(1));
        
        document.body.addEventListener('click', (e) => {
            if (e.target.classList.contains('rehome-button')) {
                const guppyId = parseInt(e.target.dataset.guppyId);
                rehomeGuppy(guppyId);
            }
            if (!e.target.closest('.guppy') && !e.target.closest('#guppy-info-panel') && !e.target.closest('#guppy-list-modal')) {
                guppyInfoPanel.classList.add('hidden');
            }
            if (e.target.id === 'aquarium') {
                if(gameState.isBreedingMode) {
                    cancelBreeding();
                    showToast('ÍµêÎ∞∞Í∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.');
                }
            }
            if (e.target.classList.contains('close-modal-button') || e.target.classList.contains('modal-overlay')) {
                const modal = e.target.closest('.modal-overlay');
                if (modal) {
                     if (modal.id === 'breed-modal') cancelBreeding();
                     modal.remove();
                }
            }
            if (e.target.classList.contains('buy-button')) {
                buyItem(e.target.dataset.itemId);
            }
            if (e.target.classList.contains('move-to-aq-button')) {
                const targetIndex = parseInt(e.target.dataset.targetIndex);
                const guppyToMove = findGuppyById(gameState.currentInfoGuppyId);
                const sourceAq = gameState.aquariums[gameState.currentAquariumIndex];
                
                const guppyIndex = sourceAq.guppies.findIndex(g => g.id === guppyToMove.id);
                if (guppyIndex > -1) {
                    sourceAq.guppies.splice(guppyIndex, 1);
                    guppyToMove.destroy();
                    
                    gameState.aquariums[targetIndex].guppies.push(guppyToMove);
                    
                    guppyInfoPanel.classList.add('hidden');
                    e.target.closest('.modal-overlay').remove();
                    showToast(`Íµ¨ÌîºÎ•º ÏàòÏ°∞ ${targetIndex + 1}(Ïúº)Î°ú ÏòÆÍ≤ºÏäµÎãàÎã§.`);
                }
            }
        });

        function openModal(type) {
             const modal = document.createElement('div');
             modal.id = `${type}-modal`;
             modal.className = 'modal-overlay';
             let content = '';
             switch(type) {
                case 'manual':
                    content = `
                        <h2 class="text-3xl font-bold mb-4 text-cyan-300">Guppy Lab Í≤åÏûÑ Îß§Îâ¥Ïñº</h2>
                        <p class="text-slate-300">Îã§ÏñëÌïú ÏÉâÏÉÅÍ≥º Ìå®ÌÑ¥ÏùÑ Í∞ÄÏßÑ Íµ¨ÌîºÎì§ÏùÑ ÍµêÎ∞∞ÏãúÏºú ÏÑ∏ÏÉÅÏóê ÌïòÎÇòÎøêÏù∏ ÌäπÎ≥ÑÌïú Íµ¨Ìîº Ïª¨Î†âÏÖòÏùÑ ÎßåÎìúÎäî Í≤ÉÏù¥ Î™©ÌëúÏûÖÎãàÎã§.</p>
                        <h3 class="text-xl font-semibold mt-4 mb-2 text-cyan-400">Íµ¨Ìîº Í¥ÄÎ¶¨ÌïòÍ∏∞</h3>
                        <ul class="list-disc list-inside space-y-2 text-slate-300">
                            <li><b>Î®πÏù¥Ï£ºÍ∏∞</b>: Íµ¨ÌîºÎì§Ïù¥ Î∞∞Í≥†Ìåå ÏàòÎ©¥ÏóêÏÑú ÏûÖÏßàÏùÑ ÌïòÎ©¥ 'Î®πÏù¥Ï£ºÍ∏∞' Î≤ÑÌäº(10ÏΩîÏù∏)ÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.</li>
                            <li><b>Ï≤≠ÏÜåÌïòÍ∏∞</b>: 'Ï≤≠ÏÜåÌïòÍ∏∞' Î≤ÑÌäºÏúºÎ°ú ÏàòÏßàÏùÑ 100%Î°ú ÌöåÎ≥µÏãúÌÇ¨ Ïàò ÏûàÏäµÎãàÎã§.</li>
                            <li><b>ÏÑ±Ïû•</b>: Íµ¨ÌîºÎäî 20Ï¥àÍ∞Ä ÏßÄÎÇòÎ©¥ 'ÏπòÏñ¥'ÏóêÏÑú 'ÏÑ±Ïñ¥'Î°ú ÏÑ±Ïû•ÌïòÎ©∞, ÏÑ±Ïñ¥Îßå ÍµêÎ∞∞Ìï† Ïàò ÏûàÏäµÎãàÎã§.</li>
                        </ul>
                        <h3 class="text-xl font-semibold mt-4 mb-2 text-cyan-400">ÍµêÎ∞∞ (Î∏åÎ¶¨Îî©)</h3>
                        <ul class="list-disc list-inside space-y-2 text-slate-300">
                            <li><b>ÏàòÎèô ÍµêÎ∞∞</b>: 'ÍµêÎ∞∞ ÏãúÏûëÌïòÍ∏∞' Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Í±∞ÎÇò Íµ¨Ìîº Ï†ïÎ≥¥Ï∞ΩÏóêÏÑú 'ÍµêÎ∞∞'Î•º ÏÑ†ÌÉùÌï¥ ÏßÅÏ†ë ÏßùÏùÑ Îß∫Ïñ¥Ï§Ñ Ïàò ÏûàÏäµÎãàÎã§.</li>
                            <li><b>ÏûêÎèô Î≤àÏãù</b>: ÌóàÍ∏∞Í∞Ä 20 ÎØ∏ÎßåÏù∏ ÏÑ±Ïñ¥Îì§ÏùÄ ÏÑúÎ°ú ÎßåÎÇòÎ©¥ Ïä§Ïä§Î°ú Î≤àÏãùÌïòÍ∏∞ÎèÑ Ìï©ÎãàÎã§.</li>
                        </ul>
                        <h3 class="text-xl font-semibold mt-4 mb-2 text-cyan-400">Í∏∞ÌÉÄ ÌåÅ</h3>
                        <ul class="list-disc list-inside space-y-2 text-slate-300">
                            <li><b>ÏàòÏ°∞ Í¥ÄÎ¶¨</b>: ÏÉÅÏ†êÏóêÏÑú ÏÉà ÏàòÏ°∞Î•º Íµ¨Îß§ÌïòÍ≥†, ÏàòÏ°∞ ÏòÜ ÌôîÏÇ¥ÌëúÎ°ú Ïù¥ÎèôÌï† Ïàò ÏûàÏäµÎãàÎã§. Íµ¨Ìîº Ï†ïÎ≥¥Ï∞ΩÏóêÏÑú Îã§Î•∏ ÏàòÏ°∞Î°ú Íµ¨ÌîºÎ•º ÏòÆÍ∏∏ ÏàòÎèÑ ÏûàÏäµÎãàÎã§.</li>
                            <li><b>ÏÉÅÏÑ∏ Ï†ïÎ≥¥</b>: Ïö∞Ï∏° ÏÉÅÎã®Ïùò Î¨ºÍ≥†Í∏∞(üêü) Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÌòÑÏû¨ ÏàòÏ°∞Ïùò Íµ¨Ìîº Î™©Î°ùÏùÑ Ïó¥Í≥†, Î™©Î°ùÏóêÏÑú Íµ¨ÌîºÎ•º ÌÅ¥Î¶≠Ìï¥ ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.</li>
                            <li><b>ÏΩîÏù∏ ÏñªÍ∏∞</b>: ÏÉàÎ°úÏö¥ Ï°∞Ìï©Ïùò Íµ¨ÌîºÎ•º ÌÉÑÏÉùÏãúÌÇ§Î©¥ 50ÏΩîÏù∏ÏùÑ ÏñªÏäµÎãàÎã§.</li>
                            <li><b>ÏûêÎèô Ï†ÄÏû•</b>: Í≤åÏûÑÏùÄ 1Ï¥àÎßàÎã§ ÏûêÎèôÏúºÎ°ú Ï†ÄÏû•Îê©ÎãàÎã§.</li>
                        </ul>`;
                    break;
             }
             modal.innerHTML = `
                <div class="modal-content">
                    <button class="close-modal-button absolute top-4 right-4 text-2xl font-bold text-slate-400 hover:text-white">&times;</button>
                    ${content}
                </div>`;
            modalContainer.appendChild(modal);
        }

        manualButton.addEventListener('click', () => openModal('manual'));
        guppyListButton.addEventListener('click', openGuppyList);
        shopButton.addEventListener('click', openShop);
        collectionButton.addEventListener('click', openCollection);

        function init() {
            if (!loadGame()) {
                const p1 = { type: 'spots', colors: [{ r: 255, g: 255, b: 255 }, { r: 255, g: 0, b: 0 }] };
                const p2 = { type: 'stripes', colors: [{ r: 20, g: 20, b: 255 }, { r: 255, g: 255, b: 0 }] };
                const guppy1 = new Guppy(gameState.nextGuppyId++, p1);
                const guppy2 = new Guppy(gameState.nextGuppyId++, p2);
                gameState.aquariums[0].guppies.push(guppy1, guppy2);
                gameState.discoveredPatterns.add(getPatternKey(p1));
                gameState.discoveredPatterns.add(getPatternKey(p2));
            }
            
            for (let i = 0; i < 10; i++) {
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                bubble.style.left = `${Math.random() * 100}%`;
                bubble.style.animationDuration = `${Math.random() * 3 + 4}s`;
                bubble.style.animationDelay = `${Math.random() * 4}s`;
                aquarium.appendChild(bubble);
            }
            
            renderCurrentAquarium();
            setInterval(tickLoop, 1000);
            requestAnimationFrame(renderLoop);
        }
    </script>
</body>
</html>